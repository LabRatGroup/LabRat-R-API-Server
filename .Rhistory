data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
}
}
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue > max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
}
}
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue > max) {
}
}
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
#data.training.prediction[[method]] <- predict(data.model[[method]], data.test)
#data.training.confusionMatrix[[method]] <- confusionMatrix(data.prediction[[method]],  data.test$prediction, positive = positive)
# metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
#if(metricValue > max) {
# max <- metricValue
#data.model <- data.training.model[[method]]
#data.prediction <- data.training.prediction[[method]]
#data.confusionMatrix <- data.training.confusionMatrix[[method]]
#}
}
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.model[[method]], data.test)
#data.training.confusionMatrix[[method]] <- confusionMatrix(data.prediction[[method]],  data.test$prediction, positive = positive)
# metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
#if(metricValue > max) {
# max <- metricValue
#data.model <- data.training.model[[method]]
#data.prediction <- data.training.prediction[[method]]
#data.confusionMatrix <- data.training.confusionMatrix[[method]]
#}
}
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue > max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
}
}
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
}
}
data.model
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- row
}
}
data.params
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row]
}
}
data.params
dfParams[1]
dfParams[1,]
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
data.params
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", token))
saveRDS(data.model, file=filename)
insertSql_1 <- "INSERT INTO `ml_model_state_scores` "
insertSql_2 <- "(`results`, `token`, `ml_model_state_id`, `params`, `kappa`, `accuracy`, `confusion_matrix`, `sensitivity`, `specificity`, `precision`, `recall`, `created_at`, `updated_at`, `deleted_at`) values "
insertSql_3 <- sprintf("('%s','%s',%s,'%s',%s ,%s ,'%s', %s, %s, %s, %s,'%s','%s',NULL)",
toJSON(data.model$results),
data.query$token,
data.query$ml_model_state_id,
toJSON(data.params),
data.confusionMatrix$overall['Kappa'][[1]],
data.confusionMatrix$overall['Accuracy'][[1]],
toJSON(as.data.frame(data.confusionMatrix$table)),
data.confusionMatrix$byClass['Sensitivity'][[1]],
data.confusionMatrix$byClass['Specificity'][[1]],
data.confusionMatrix$byClass['Precision'][[1]],
data.confusionMatrix$byClass['Recall'][[1]],
Sys.time(),
Sys.time())
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
insertSql_1 <- "INSERT INTO `ml_model_state_scores` "
insertSql_2 <- "(`results`, `token`, `ml_model_state_id`, `params`, `kappa`, `accuracy`, `confusion_matrix`, `sensitivity`, `specificity`, `precision`, `recall`, `created_at`, `updated_at`, `deleted_at`) values "
insertSql_3 <- sprintf("('%s','%s',%s,'%s',%s ,%s ,'%s', %s, %s, %s, %s,'%s','%s',NULL)",
toJSON(data.model$results),
data.query$token,
data.query$ml_model_state_id,
toJSON(data.params),
data.confusionMatrix$overall['Kappa'][[1]],
data.confusionMatrix$overall['Accuracy'][[1]],
toJSON(as.data.frame(data.confusionMatrix$table)),
data.confusionMatrix$byClass['Sensitivity'][[1]],
data.confusionMatrix$byClass['Specificity'][[1]],
data.confusionMatrix$byClass['Precision'][[1]],
data.confusionMatrix$byClass['Recall'][[1]],
Sys.time(),
Sys.time())
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "GWY2AWal1ESJZnQVeEVOjSYO4"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
libraries <- c("RMySQL", "RJSONIO", "caret", "mongolite")
check.libraries <- is.element(libraries, installed.packages()[, 1])==FALSE
libraries.to.install <- libraries[check.libraries]
if (length(libraries.to.install!=0)) {
install.packages(libraries.to.install, repos = "http://cran.us.r-project.org", dependencies = TRUE)
}
success <- sapply(libraries,require, quietly = FALSE,  character.only = TRUE)
if(length(success) != length(libraries)) {stop("A package failed to return a success in require() function.")}
require(jsonlite)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "oFlXMoz6blqEwYA0tnKnsf5v8"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT * FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT * FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Load model
source(file.path("./scripts/grid/", sprintf("%s.R", data.params$method)))
#Predict
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", data.state$token))
data.model <- readRDS(filename)
#Predict
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", data.state$token))
data.model <- readRDS(filename)
data.prediction <- predict(data.model, data.raw)
data.prediction <- as.data.frame(data.prediction)
colnames(data.prediction) <- c('prediction')
data.prediction$sample <- data.raw$sample
data.prediction$ml_model_prediction_data_id <- as.integer(data.query$id)
mongoCon <- mongo(collection = "ml_model_prediction_score", db = "labrat")
mongoCon$insert(as.data.frame(data.prediction))
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT * FROM ml_model_prediction_datas WHERE token = '%s'", token))
libraries <- c("RMySQL", "RJSONIO", "caret", "mongolite")
check.libraries <- is.element(libraries, installed.packages()[, 1])==FALSE
libraries.to.install <- libraries[check.libraries]
if (length(libraries.to.install!=0)) {
install.packages(libraries.to.install, repos = "http://cran.us.r-project.org", dependencies = TRUE)
}
success <- sapply(libraries,require, quietly = FALSE,  character.only = TRUE)
if(length(success) != length(libraries)) {stop("A package failed to return a success in require() function.")}
require(jsonlite)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "oFlXMoz6blqEwYA0tnKnsf5v8"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT cast(id as CHAR(25)) as id, token, file_path, cast(ml_model_prediction_id as CHAR(25)) as ml_model_state_id FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT token FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Retrieving data for model analysis
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Predict
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", data.state$token))
data.state <- dbGetQuery(connection, sprintf("SELECT token FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
data.state <- dbGetQuery(connection, sprintf("SELECT token, ml_model_state_id FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Retrieving data for model analysis
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Predict
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", data.state$token))
data.model <- readRDS(filename)
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT cast(id as CHAR(25)) as id, token, file_path, cast(ml_model_prediction_id as CHAR(25)) as ml_model_state_id FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT token, ml_model_state_id FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
data.state <- dbGetQuery(connection, sprintf("SELECT token, ml_model_state_id FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", as.integer(data.query$ml_model_prediction_id)))
data.state <- dbGetQuery(connection, sprintf("SELECT token, ml_model_state_id FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", as.integer(data.query$ml_model_prediction_id)))
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT cast(id as CHAR(25)) as id, token, file_path, cast(ml_model_prediction_id as CHAR(25)) as ml_model_state_id FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT token, ml_model_state_id FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", as.integer(data.query$ml_model_prediction_id)))
data.state <- dbGetQuery(connection, sprintf("SELECT * FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT cast(id as CHAR(25)) as id, token, file_path, cast(ml_model_prediction_id as CHAR(25)) as ml_model_prediction_id FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT * FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
data.state <- dbGetQuery(connection, sprintf("SELECT token FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT cast(id as CHAR(25)) as id, token, file_path, cast(ml_model_prediction_id as CHAR(25)) as ml_model_prediction_id FROM ml_model_prediction_datas WHERE token = '%s'", token))
data.state <- dbGetQuery(connection, sprintf("SELECT token FROM ml_model_state_training_datas WHERE ml_model_state_id = '%s'", data.query$ml_model_prediction_id))
# Retrieving data for model analysis
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Predict
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", data.state$token))
data.model <- readRDS(filename)
data.prediction <- predict(data.model, data.raw)
data.prediction <- as.data.frame(data.prediction)
colnames(data.prediction) <- c('prediction')
data.prediction$sample <- data.raw$sample
data.prediction$ml_model_prediction_data_id <- as.integer(data.query$id)
