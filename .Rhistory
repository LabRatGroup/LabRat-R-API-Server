View(data.raw)
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", token))
saveRDS(data.model, file=filename)
data.stats <- as.data.frame(data.confusionMatrix$byClass)
insertSql_1 <- "INSERT INTO `ml_model_state_scores` "
insertSql_2 <- "(`results`, `token`, `ml_model_state_id`, `params`, `kappa`, `accuracy`, `confusion_matrix`, `sensitivity`, `specificity`, `precision`, `recall`, `created_at`, `updated_at`, `deleted_at`) values "
insertSql_3 <- sprintf("('%s','%s',%s,'%s',%s ,%s ,'%s', %s, %s, %s, %s,'%s','%s',NULL)",
toJSON(data.model$results),
data.query$token,
data.query$ml_model_state_id,
toJSON(data.params),
data.confusionMatrix$overall['Kappa'][[1]],
data.confusionMatrix$overall['Accuracy'][[1]],
toJSON(as.data.frame(data.confusionMatrix$table)),
data.stats[paste0('Class: ',dfParams$positive),1],
data.stats[paste0('Class: ',dfParams$positive),2],
data.stats[paste0('Class: ',dfParams$positive),5],
data.stats[paste0('Class: ',dfParams$positive),6],
Sys.time(),
Sys.time())
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
lapply( dbListConnections( dbDriver( drv = "MySQL")), dbDisconnect)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "sBIIFbQaWKlD9azZxqbuJsv0D"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "9Nj1uKKC9TSSNHKZ2Cgtx7DRU"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
View(data.query)
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
data.params
View(dfParams)
View(dfParams)
lapply( dbListConnections( dbDriver( drv = "MySQL")), dbDisconnect)
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "9Nj1uKKC9TSSNHKZ2Cgtx7DRU"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
data.params
View(dfParams)
# Set java home location
#if (Sys.info()['sysname'] == 'Darwin') {
#  libjvm <- paste0(system2('/usr/libexec/java_home',stdout = TRUE)[1],'/jre/lib/server/libjvm.dylib')
#  message (paste0('Load libjvm.dylib from: ',libjvm))
#  dyn.load(libjvm)
#}
# Load libraries and packages
libraries <- c("RMySQL", "RJSONIO", "caret", "mongolite")
check.libraries <- is.element(libraries, installed.packages()[, 1])==FALSE
libraries.to.install <- libraries[check.libraries]
if (length(libraries.to.install!=0)) {
install.packages(libraries.to.install, repos = "http://cran.us.r-project.org", dependencies = TRUE)
}
success <- sapply(libraries,require, quietly = FALSE,  character.only = TRUE)
if(length(success) != length(libraries)) {stop("A package failed to return a success in require() function.")}
require(jsonlite)
options(verbose = FALSE)
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "9Nj1uKKC9TSSNHKZ2Cgtx7DRU"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
View(data.env)
View(data.params)
View(data.query)
View(data.raw)
View(data.query)
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
dfParams$tune[[1]]$k$min
dfParams$tune[[1]]$k$max
dfParams$tune[[1]]$k$step
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
c(preprocessing)
ctrl
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
tuneGrid = grid,
metric = metric
)
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
data.params
ctrl
trainControlMethod
trainControlMethodRounds
# Get MySQL connection param from env variables
data.env <-read.csv('env', header=TRUE, sep = ",", dec = ",")
connection <- dbConnect(
MySQL(),
user=toString(data.env$dbUser),
password=toString(data.env$dbpassword),
host=toString(data.env$dbHost),
dbname=toString(data.env$dbName)
)
# Catch collection token from script params
args <- commandArgs(trailingOnly = TRUE)
#token <- args[1]
token <- "9Nj1uKKC9TSSNHKZ2Cgtx7DRU"
# Querying data from MySQL
data.query <- dbGetQuery(connection, sprintf("SELECT token, params, file_path, cast(ml_model_state_id as CHAR(25)) as ml_model_state_id FROM ml_model_state_training_datas WHERE token = '%s'", token))
# Retrieving data for model analysis
data.params <- fromJSON(data.query$params)
dir <- paste(data.env$dataDir,"/",data.env$sftpUser, sep="")
data.raw <- read.csv(file.path(dir, data.query$file_path), header=TRUE, sep = ";", dec = ",")
#Create model
set.seed(123)
data.in_train <- createDataPartition(data.raw$prediction, p = 0.67, list = FALSE)
data.training <- data.raw[data.in_train, ]
data.test <- data.raw[-data.in_train, ]
dfParams <- as.data.frame(fromJSON(data.query$params))
data.training.model <- list()
data.training.prediction <- list()
data.training.confusionMatrix <- list()
max = 0
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = trainControlMethodRounds
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
data.params
filename <- file.path(sprintf("%s/models",dir),sprintf("%s.rda", token))
saveRDS(data.model, file=filename)
data.stats <- as.data.frame(data.confusionMatrix$byClass)
insertSql_1 <- "INSERT INTO `ml_model_state_scores` "
insertSql_2 <- "(`results`, `token`, `ml_model_state_id`, `params`, `kappa`, `accuracy`, `confusion_matrix`, `sensitivity`, `specificity`, `precision`, `recall`, `created_at`, `updated_at`, `deleted_at`) values "
insertSql_3 <- sprintf("('%s','%s',%s,'%s',%s ,%s ,'%s', %s, %s, %s, %s,'%s','%s',NULL)",
toJSON(data.model$results),
data.query$token,
data.query$ml_model_state_id,
toJSON(data.params),
data.confusionMatrix$overall['Kappa'][[1]],
data.confusionMatrix$overall['Accuracy'][[1]],
toJSON(as.data.frame(data.confusionMatrix$table)),
data.stats[paste0('Class: ',dfParams$positive),1],
data.stats[paste0('Class: ',dfParams$positive),2],
data.stats[paste0('Class: ',dfParams$positive),5],
data.stats[paste0('Class: ',dfParams$positive),6],
Sys.time(),
Sys.time())
insertSql <- paste0(insertSql_1, insertSql_2, insertSql_3, seq="")
dbExecute(connection, insertSql)
lapply( dbListConnections( dbDriver( drv = "MySQL")), dbDisconnect)
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = as.numeric(trainControlMethod),
number = as.numeric(trainControlMethodRounds)
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
for (row in 1:nrow(dfParams)) {
method <- dfParams[row, "method"]
metric <- dfParams[row, "metric"]
preprocessing <- dfParams[row, "preprocessing"]
positive <- dfParams[row, "positive"]
trainControlMethod <- dfParams[row, "control"]$trainControlMethod
trainControlMethodRounds <- dfParams[row, "control"]$trainControlMethodRounds
ctrl <- trainControl(
method = trainControlMethod,
number = as.numeric(trainControlMethodRounds)
)
source(file.path("./scripts/grid/", sprintf("%s.R", method)))
data.training.model[[method]] <- train(
prediction ~ .,
data = data.training,
method = method,
preProcess = c(preprocessing),
trControl = ctrl,
tuneGrid = grid,
metric = metric
)
data.training.prediction[[method]] <- predict(data.training.model[[method]], data.test)
data.training.confusionMatrix[[method]] <- confusionMatrix(data.training.prediction[[method]],  data.test$prediction, positive = positive)
metricValue <- data.training.confusionMatrix[[method]]$overall[[metric]]
if(metricValue >= max) {
max <- metricValue
data.model <- data.training.model[[method]]
data.prediction <- data.training.prediction[[method]]
data.confusionMatrix <- data.training.confusionMatrix[[method]]
data.params <- dfParams[row,]
}
}
